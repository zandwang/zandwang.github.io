<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>50度灰 | zand’s blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="50度灰" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文为译文，原文链接：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" />
<meta property="og:description" content="本文为译文，原文链接：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" />
<link rel="canonical" href="zand.wang/go/2022/01/04/gotchas_and_common_mistakes_in_golang.html" />
<meta property="og:url" content="zand.wang/go/2022/01/04/gotchas_and_common_mistakes_in_golang.html" />
<meta property="og:site_name" content="zand’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-04T06:12:34+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="50度灰" />
<script type="application/ld+json">
{"dateModified":"2022-01-04T06:12:34+08:00","datePublished":"2022-01-04T06:12:34+08:00","url":"zand.wang/go/2022/01/04/gotchas_and_common_mistakes_in_golang.html","mainEntityOfPage":{"@type":"WebPage","@id":"zand.wang/go/2022/01/04/gotchas_and_common_mistakes_in_golang.html"},"description":"本文为译文，原文链接：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/","@type":"BlogPosting","headline":"50度灰","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="zand.wang/feed.xml" title="zand's blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">zand&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">50度灰</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-01-04T06:12:34+08:00" itemprop="datePublished">Jan 4, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>本文为译文，原文链接：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</p>

<p>Go是一个简单有趣的语言，但是像其他语言一样，它有一些小坑。。。很多坑并不是go的错。如果你从其他语言转过来有一些陷阱就很自然踩到。其他一些是基于一些错误的假设和细节的忽略。</p>

<p>如果你花费了时间通过阅读官方细则、wiki、邮件讨论、Rob Pike很多很棒的文章演讲以及源码去学习go语言，那么很多坑可能是显而易见的。当然不是每一个人都是这么开始学习go的，不过也没关系，如果你是go的新人，这里的信息将节省一点调试代码的时间。</p>

<p>总：
[toc]</p>

<h1 id="陷阱圈套和常见错误">陷阱，圈套和常见错误</h1>
<h2 id="1左大括号不能放置在单独一行">1.左大括号不能放置在单独一行</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>在大多数使用大括号的语言中，你可以自己选择把它放在哪。go不一样。你可以感谢自动分号注入（没有提前）的行为。是的，go有分号 :-)</p>

<h3 id="错误示范">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span><span class="c">// error, can't have the opening brace on a separate line</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello there!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误">编译错误：</h3>
<blockquote>
  <p>./main.go:5:6: missing function body
./main.go:6:1: syntax error: unexpected semicolon or newline before {</p>
</blockquote>

<h3 id="正确示例">正确示例：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"works!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="2未使用的变量">2.未使用的变量</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>如果你有未使用的变量那么你的代码将无法编译。不过也有例外。你必须使用你在函数里声明的变量，但是可以有未使用的全局变量。也可以有未使用的函数参数。</p>

<p>如果你给未使用的变量赋一个新值，你的代码仍然不能编译。你需要在某些地方使用这个变量来让编译器高兴</p>

<h3 id="错误示范-1">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">var</span> <span class="n">gvar</span> <span class="kt">int</span> <span class="c">// not an error</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">one</span> <span class="kt">int</span> <span class="c">// error, unused variable</span>
    <span class="n">two</span> <span class="o">:=</span> <span class="m">2</span> <span class="c">// error, unuserd variable</span>
    <span class="k">var</span> <span class="n">three</span> <span class="kt">int</span> <span class="c">// error, even though it's assigned 3 on the next line</span>
    <span class="n">three</span> <span class="o">=</span> <span class="m">3</span>

    <span class="k">func</span> <span class="p">(</span><span class="n">unuserd</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Unused arg. No compile error"</span><span class="p">)</span>
    <span class="p">}</span> <span class="p">(</span><span class="s">"what?"</span><span class="p">)</span>
<span class="p">}</span> 
</code></pre></div></div>

<h3 id="编译错误-1">编译错误：</h3>
<blockquote>
  <p>./main.go:8:6: one declared but not used
./main.go:9:2: two declared but not used
./main.go:10:6: three declared but not used</p>
</blockquote>

<h3 id="正确示例-1">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">one</span> <span class="kt">int</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">one</span>

    <span class="n">two</span> <span class="o">:=</span> <span class="m">2</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>

    <span class="k">var</span> <span class="n">three</span> <span class="kt">int</span>
    <span class="n">three</span> <span class="o">=</span> <span class="m">3</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">three</span>

    <span class="k">var</span> <span class="n">four</span> <span class="kt">int</span>
    <span class="n">four</span> <span class="o">=</span> <span class="n">four</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另一个选择是注释或者移除未使用的变量 :-)</p>

<h2 id="3-未使用的导入">3. 未使用的导入</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>如果你导入了一个包，但是没有使用任何它可导出的函数、接口、结构体或者变量，那么你的代码将会编译失败</p>

<p>如果你真的需要导入这个包你可以使用空白标志符<code class="language-plaintext highlighter-rouge">_</code>来作为包的名字以避免编译失败。空白标识符用于导入包的副作用。</p>

<h3 id="错误示范-2">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-2">编译错误</h3>
<blockquote>
  <p>main.go:4: imported and not used: “fmt”</p>
</blockquote>

<h3 id="正确示例-2">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="n">_</span> <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>另一个选项是移除或者注释未使用的导入 :-) ，<code class="language-plaintext highlighter-rouge">goimports</code>工具将帮助你做这些事</p>

<h2 id="4-短变量声明只能在函数内使用">4. 短变量声明只能在函数内使用</h2>
<ul>
  <li>等级：初级</li>
</ul>

<h3 id="错误示范-3">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="n">myvar</span> <span class="o">:=</span> <span class="m">1</span> <span class="c">// error</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>
<h3 id="编译错误-3">编译错误</h3>
<blockquote>
  <p>./main.go:3:1: syntax error: non-declaration statement outside function body</p>
</blockquote>

<h3 id="正确示例-3">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">var</span> <span class="n">myvar</span> <span class="o">=</span> <span class="m">1</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="5-使用短变量声明来重新声明变量">5. 使用短变量声明来重新声明变量</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>你不能在一个独立语句中重新声明一个变量，但是在至少有一个新变量声明的多变量声明中是允许的。</p>

<p>重新声明变量必须在同一代码块否则你将得到一个被覆盖的变量（参见 Accidental Variable Shadowing）。</p>

<h3 id="错误示范-4">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">one</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="n">one</span> <span class="o">:=</span> <span class="m">1</span> <span class="c">// error</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译失败">编译失败</h3>
<blockquote>
  <p>./main.go:5:6: no new variables on left side of :=</p>
</blockquote>

<h3 id="正确示例-4">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">one</span> <span class="o">:=</span> <span class="m">0</span>
    <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">:=</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span>

    <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">=</span> <span class="n">two</span><span class="p">,</span> <span class="n">one</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="6-不能使用短变量声明来设置结构体字段值">6. 不能使用短变量声明来设置结构体字段值</h2>
<ul>
  <li>等级：初级</li>
</ul>

<h3 id="错误示范-5">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">info</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">result</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">work</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="m">13</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">data</span> <span class="n">info</span>

    <span class="n">data</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">work</span><span class="p">()</span> <span class="c">// error</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"info: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译失败-1">编译失败</h3>
<blockquote>
  <p>./main.go:18:9: non-name data.result on left side of :=</p>
</blockquote>

<p>尽管有个issue可以解决这个问题但可能不会改变，因为Rob Pike认为”as is” :-)</p>

<p>使用临时变量或者预先声明所有变量并使用标准赋值操作符</p>

<h3 id="正确示例-5">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">info</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">result</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">work</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="m">13</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">data</span> <span class="n">info</span>

    <span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
    <span class="n">data</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">work</span><span class="p">()</span> <span class="c">// ok</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"info: %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c">//prints: info: {result:13}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="7-意外的变量覆盖">7. 意外的变量覆盖</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>短变量声明如此方便（特别是对于从动态语言过来的程序员来说）以至于很容易将其当做一个常规的赋值操作符。如果你在新的代码块中犯了这个错误，将不会有编译错误，但是你的程序运行将不会是你期望的</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="m">1</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c">// prints 1</span>
    <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// prints 1</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="m">2</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// prints 2</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>     <span class="c">// prints 1(bad if you need 2)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>即便是对有经验的go开发者来说这也是个常见的错误。这很容易出现并且难以发现
你可以使用<code class="language-plaintext highlighter-rouge">vet</code>命令来找到类似的问题。默认情况下，<code class="language-plaintext highlighter-rouge">vet</code>不会执行覆盖变量的检查。请使用<code class="language-plaintext highlighter-rouge">-shadow</code>参数:<code class="language-plaintext highlighter-rouge">go tool vet -shadow your—file.go</code></p>

<p>注意<code class="language-plaintext highlighter-rouge">vet</code> 命令不会报告所有的覆盖变量。使用<code class="language-plaintext highlighter-rouge">go-nyet</code>来进行更强力的覆盖变量检测</p>

<h2 id="8-不能使用nil来初始化未显示定义类型的变量">8. 不能使用nil来初始化未显示定义类型的变量</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>nil标志符可以作为接口、函数、指针、字典、切片和通道的零值。如果你不指定变量的类型编译器将会编译失败，因为它猜不出类型。</p>

<h3 id="错误示范-6">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">//  main.go|4col·10·error|·use·of·untyped·nil·in·variable·declaration</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">x</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-4">编译错误</h3>

<blockquote>
  <p>./main.go:4:6: use of untyped nil</p>
</blockquote>

<h3 id="正确示例-6">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">x</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="9-使用nil切片和nil字典">9. 使用nil切片和nil字典</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>向nil切片中添加值是可以的，但是向nil字典中添加值会导致panic</p>

<h3 id="正确示例-7">正确示例：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="错误示范-7">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"one"</span><span class="p">]</span> <span class="o">=</span> <span class="m">1</span> <span class="c">// panic: assignment to entry in nil map</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="10-字典容量">10. 字典容量</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>你可以在字典创建时指定字典的容量，但是你不能在字典上使用<code class="language-plaintext highlighter-rouge">cap()</code>函数</p>

<h3 id="错误示范-8">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m</span> <span class="o">:=</span>  <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="m">99</span><span class="p">)</span>
    <span class="nb">cap</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c">// invalid argument: m (variable of type map[string]int) for cap</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-5">编译错误</h3>
<blockquote>
  <p>./main.go:5:5: invalid argument m (type map[string]int) for cap</p>
</blockquote>

<h2 id="11-字符串不能是nil">11. 字符串不能是nil</h2>
<ul>
  <li>等级：初级
这是开发者经常犯的错误，将nil赋值给字符串变量</li>
</ul>

<h3 id="错误示范-9">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="kt">string</span> <span class="o">=</span> <span class="no">nil</span> <span class="c">// cannot use nil (untyped nil value) as string value in variable declaration</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span> <span class="c">// cannot convert nil (untyped nil value) to string</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s">"default"</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-6">编译错误</h3>
<blockquote>
  <p>./main.go:4:6: cannot use nil as type string in assignment
./main.go:6:7: invalid operation: x == nil (mismatched types string and nil)</p>
</blockquote>

<h3 id="正确示例-8">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="kt">string</span> 

    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s">"default"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="12-数组函数参数">12. 数组函数参数</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>如果你曾是C或者C++开发者，你对数组的印象肯定是指针。当你在函数中传入数组时，函数指向相同的内存区域，所以它们将会更新原始的数据。数组在go中是值传递，所以你给函数传入数组时，函数得到的是原始数组的拷贝。如果你想更新数组的数组就会出问题</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">}</span>

    <span class="k">func</span><span class="p">(</span><span class="n">arr</span> <span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">7</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// prints[7 2 3]</span>
    <span class="p">}</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// prints [1 2 3] (不是你期望的[7 2 3])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果你需要更新原始数组数据需要传递数组指针</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>

    <span class="k">func</span><span class="p">(</span><span class="n">arr</span> <span class="o">*</span><span class="p">[</span><span class="m">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">7</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// prints &amp;[7 2 3]</span>
    <span class="p">}</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// prints [7 2 3]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另一个方法是使用切片。尽管函数获得的也是切片的copy但是仍然指向原始的数据</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>

    <span class="k">func</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">7</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// prints [7 2 3]</span>
    <span class="p">}</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">// prints [7 2 3]</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="13-在数组和切片遍历中未期望的值">13. 在数组和切片遍历中未期望的值</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>你在其他语言中习惯使用<code class="language-plaintext highlighter-rouge">for in</code>或者<code class="language-plaintext highlighter-rouge">for each</code>语句就会遇到这个问题。<code class="language-plaintext highlighter-rouge">range</code>语句在go中不一样。它产生两个值：第一个值是每一项的索引，第二个值是项本身的数据</p>

<h3 id="错误示范-10">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">x</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c">// prints 0, 1, 2</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="正确示例-9">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">x</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c">// prints a, b, c</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="14-切片和数组是一维的">14. 切片和数组是一维的</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>go似乎支持多维数组和切片，但实际不支持。不过创建数组或切片的数组是可行的。对于依赖动态多维数组的数值计算程序来说，在性能和复杂度方面远远不够理想。</p>

<p>你可以使用原始的一维数组、独立切片和共享数据切片来构建动态多维数组</p>

<p>如果你使用原始一维数组，当数组扩容时你需要负责索引、界限检查和内存分配</p>

<p>创建动态多维数组使用独立切片需要两步。第一，你需要创建外层切片，然后，分配每一个内部切片。内部切片是相互独立的。你可以在不影响其他切片的情况下扩缩容。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="m">2</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="m">4</span>

    <span class="n">table</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">table</span> <span class="p">{</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用共享数据切片来创建动态多维数组需要三步。第一，创建一个容器切片保存所有原始数据，然后，创建外层切片，最后，通过重新切片原始数据来初始化各个内部切片。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span>

    <span class="n">raw</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">h</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">raw</span> <span class="p">{</span>
        <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">raw</span><span class="p">[</span><span class="m">4</span><span class="p">])</span>
    <span class="c">// prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;</span>

    <span class="n">table</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">table</span> <span class="p">{</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">w</span><span class="o">:</span><span class="n">i</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">table</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">table</span><span class="p">[</span><span class="m">1</span><span class="p">][</span><span class="m">0</span><span class="p">])</span>
    <span class="c">//prints: [[0 1 2 3][ 4 5 6 7]] &lt;prt_addr_x&gt;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>有一个对多维数组和切片的规范/建议，但目前看起来是一个低优先级的特性。</p>

<h2 id="15-访问不存在的字典键">15. 访问不存在的字典键</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>这对于期望获得nil值的开发者来说是个坑（就像在其他语言那样）。只有在对应的数据类型的零值是nil的时候才会返回nil，但其他数据类型不是。检查对应的零值可以用来确定字典中记录是否存在，但这并不总是可靠（例如，字典存放的是布尔值的时候，其零值是false）。判断给定的字典值是否存在最可靠的方法是检查字典访问操作的第二个返回值。</p>

<h3 id="错误示范-11">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"two"</span><span class="o">:</span><span class="s">""</span><span class="p">,</span> <span class="s">"three"</span><span class="o">:</span><span class="s">"c"</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="s">"two"</span><span class="p">];</span> <span class="n">v</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span> <span class="c">// 错误</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"no entry"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="正确示例-10">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"two"</span><span class="o">:</span><span class="s">""</span><span class="p">,</span> <span class="s">"three"</span><span class="o">:</span><span class="s">"c"</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">x</span><span class="p">[</span><span class="s">"two"</span><span class="p">];</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"no entry"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="16-字符串是不可变的">16. 字符串是不可变的</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>想在字符串变量中使用索引操作来更新单个字符是不行的。字符串是只读的字节切片（带有一些额外的特性）。如果你需要修改字符串需要用字节切片来代替，然后在需要的时候再转成字符串。</p>

<h3 id="错误示范-12">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"text"</span>
    <span class="n">x</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'T'</span> <span class="c">// cannot assign to x[0] (value of type byte)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译失败-2">编译失败</h3>
<blockquote>
  <p>./main.go:7:7: cannot assign to x[0] (strings are immutable)</p>
</blockquote>

<h3 id="正确示例-11">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"text"</span>
    <span class="n">xbytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">xbytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'T'</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">xbytes</span><span class="p">))</span> <span class="c">// prints Text</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意这并不是修改文本字符串里字符的正确方式，因为有的字符可能使用多个字节存储。如果你确实需要修改字符串，你需要先转为rune切片。即使是rune切片，一个字符也有可能跨越多个rune，比如当你的字符是沉音符时就有可能发生。
这些复杂的和模糊的字符性质是为什么go字符串表示为字节序列的原因</p>

<h2 id="17-字符串和字节切片之间转换">17. 字符串和字节切片之间转换</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>当你将一个字符串转换为字节切片时（反之亦然），你会得到一个完整的原始数据的拷贝。它不像其他语言中的强制转换，也不是重新分片那种新切片与老切片指向同一底层数组</p>

<p>go对于<code class="language-plaintext highlighter-rouge">[]byte</code>与<code class="language-plaintext highlighter-rouge">string</code>的相互转换有一些优化来避免额外的内存分配(在待办列表上还有很多优化)</p>

<p>第一个优化在<code class="language-plaintext highlighter-rouge">[]byte</code>用于<code class="language-plaintext highlighter-rouge">map[string]</code>做key查找时避免额外的内存分配: <code class="language-plaintext highlighter-rouge">m[string(key)]</code></p>

<p>第二个优化避免了字符串转换为<code class="language-plaintext highlighter-rouge">[]byte</code>后在<code class="language-plaintext highlighter-rouge">for range</code>语句中的额外分配：<code class="language-plaintext highlighter-rouge">for i,v := range []byte(str) {...}</code>。</p>

<h2 id="18-字符串和索引操作符">18. 字符串和索引操作符</h2>
<ul>
  <li>等级：初级
索引操作符在字符串上返回的是字节值，不是字符(就像其他语言一样)</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="s">"text"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">// print 116</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%T"</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">// print uint8</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你需要用<code class="language-plaintext highlighter-rouge">for range</code>访问特殊的字符串 字符(unicode)，官方的”unicode/utf8”包和实验性的utf8string包(golang.org/x/exp/utf8string)都很有用。utfstring包 有一个很方便的函数<code class="language-plaintext highlighter-rouge">At()</code>。将字符串转为rune切片也是一种选择</p>

<h2 id="19-字符串并不总是utf8文本">19. 字符串并不总是UTF8文本</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>字符串值并不需要是UTF8文本。它可以包含任意字节。只有当字符串是字面值时才是UTF8文本，它可以通过转义序列来包含其他值。</p>

<p>想知道一个文本串是不是UTF8可以使用unicode/utf8包里的<code class="language-plaintext highlighter-rouge">ValidString()</code>函数</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"unicode/utf8"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data1</span> <span class="o">:=</span> <span class="s">"ABD"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">utf8</span><span class="o">.</span><span class="n">ValidString</span><span class="p">(</span><span class="n">data1</span><span class="p">))</span> <span class="c">// prints: true</span>

    <span class="n">data2</span> <span class="o">:=</span> <span class="s">"A</span><span class="se">\xfe</span><span class="s">C"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">utf8</span><span class="o">.</span><span class="n">ValidString</span><span class="p">(</span><span class="n">data2</span><span class="p">))</span> <span class="c">// prints: false</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="20-字符串长度">20. 字符串长度</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>假设你是一个python开发者然后你写下如下代码段</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="sa">u</span><span class="s">'♥'</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="c1"># prints: 1
</span></code></pre></div></div>
<p>当你转成Go代码时你可能会被惊讶到</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="s">"♥"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="c">// prints： 3</span>
<span class="p">}</span>
</code></pre></div></div>
<p>内置的<code class="language-plaintext highlighter-rouge">len()</code>函数返回的是字节数量而不是像python对unicode字符串那样返回字符数量</p>

<p>想在go中得到类似的结果需要使用”unicode/utf8”包中的<code class="language-plaintext highlighter-rouge">RuneCountInString()</code>函数</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"unicode/utf8"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="s">"♥"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="c">// prints： 3</span>
<span class="p">}</span>
</code></pre></div></div>
<p>技术上来说<code class="language-plaintext highlighter-rouge">RuneCountInString()</code>函数并不是返回的字符数量，因为单个字符也有可能是多个rune</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"unicode/utf8"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="s">"é"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>                    <span class="c">//prints: 3</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">utf8</span><span class="o">.</span><span class="n">RuneCountInString</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="c">//prints: 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="21-在多行切片数组字典中丢失分号">21. 在多行切片、数组、字典中丢失分号</h2>
<ul>
  <li>等级：初级</li>
</ul>

<h3 id="错误示范-13">错误示范:</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span>
        <span class="m">1</span><span class="p">,</span> 
        <span class="m">2</span> <span class="c">// missing ',' before newline in composite literal</span>
    <span class="p">}</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">x</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-7">编译错误</h3>
<blockquote>
  <p>./main.go:6:14: syntax error: unexpected newline, expecting comma or }</p>
</blockquote>

<h3 id="正确示例-12">正确示例：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span>
        <span class="m">1</span><span class="p">,</span> 
        <span class="m">2</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    
    <span class="n">y</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,}</span> <span class="c">// no error</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
<span class="p">}</span>
</code></pre></div></div>
<p>当你将声明放在一行时，末尾的分号不会有编译错误</p>

<h2 id="22-logfatal和logpanic不只是log">22. log.Fatal和log.Panic不只是Log</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>日志库一般提供不同的日志等级。不像其他日志库，Go的log包在你使用<code class="language-plaintext highlighter-rouge">Fatal*()</code>和<code class="language-plaintext highlighter-rouge">Panic*()</code>函数的时候会做更多事情。当你的程序使用这些函数go将会停掉你的程序 :-)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"log"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Fatalln</span><span class="p">(</span><span class="s">"Fatal Level: log entry"</span><span class="p">)</span> <span class="c">// app exits here</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Normal Level: log entry"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="23-内置数据结构的操作不是同步的">23. 内置数据结构的操作不是同步的</h2>
<ul>
  <li>等级：初级
尽管go有很多特性来支持原生并发，但并不包含并发安全的数据集 :-)。你需要自行保证数据集的操作是原子的。一个推荐的实现原子操作的方式是用go协程和通道，也可以使用”sync”包如果有用的话</li>
</ul>

<h2 id="24-在range语句中对字符串进行遍历">24. 在”range”语句中对字符串进行遍历</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>索引值（range语句的第一个返回值）是当前字符即返回的第二个值（unicode rune）的第一个字节的索引。不是像其他语言那样是当前字符的索引。注意一个字符可能是多个rune来表示。如果你需要处理字符最好检出”norm”包（golang.org/x/text/unicode/norm）</p>

<p>字符串中使用<code class="language-plaintext highlighter-rouge">for range</code>语句将会将数据解释为UTF8文本。对于任何不能解析的字符序列都将返回 0xfffd（）来替换真实数据。如果你的字符串有任意非UTF8文本数据，请将其转换为字节切片来获取所有数据。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">:=</span> <span class="s">"A</span><span class="se">\xfe\x02\xff\x04</span><span class="s">"</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#x "</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">// prints 0x41 0xfffd 0x2 0xfffd 0x4 (错误)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#x "</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> 
    <span class="p">}</span>
    <span class="c">// prints: // 0x41 0xfe 0x2 0xff 0x4 (正确)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="25-使用for-range遍历字典">25. 使用for range遍历字典</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>如果你期望元素是个固定值或者通过键来排序，那这就是个坑。每次字典的遍历都会产生不同的结果。go 运行时 尝试在迭代时随机化，但并不总是成功，所以你有可能得到一些相同的字典迭代结果。如果连续看到5个相同的结果不要惊讶</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span><span class="m">1</span><span class="p">,</span> <span class="s">"two"</span><span class="o">:</span><span class="m">2</span><span class="p">,</span> <span class="s">"three"</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> <span class="s">"four"</span><span class="o">:</span><span class="m">4</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">m</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果你使用go palyground(https://play.golang.org)，你会发现结果永远是一样的，因为除非你代码有改动否则不会重新编译</p>

<h2 id="26-switch中的fallthrough语句">26. switch中的fallthrough语句</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">switch</code>语句中的<code class="language-plaintext highlighter-rouge">case</code>代码块默认执行完就退出的。这和其他语言有些不同，一般的默认行为是进入下一个<code class="language-plaintext highlighter-rouge">case</code>代码块执行</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">isSpace</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="n">ch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">' '</span><span class="o">:</span> <span class="c">// error</span>
		<span class="k">case</span> <span class="sc">'\t'</span><span class="o">:</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">isSpace</span><span class="p">(</span><span class="sc">' '</span><span class="p">))</span>  <span class="c">// false(not ok)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">isSpace</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">))</span> <span class="c">// true(ok)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>你可以使用<code class="language-plaintext highlighter-rouge">fallthrough</code>强制进入下一个<code class="language-plaintext highlighter-rouge">case</code>。你也可以重写你的switch语句，在case中使用表达式列表。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">isSpace</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="n">ch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">'\t'</span><span class="o">:</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="no">false</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">isSpace</span><span class="p">(</span><span class="sc">' '</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">isSpace</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="27-自增和自减">27. 自增和自减</h2>
<ul>
  <li>等级： 初级</li>
</ul>

<p>很多语言有自增和自减操作符。不同的是，go并不支持前置操作符。另外你在表达式中不能使用这两个操作符。</p>

<h3 id="错误示范-14">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="o">++</span><span class="n">i</span> <span class="c">// expected statement, found '++'</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">])</span> <span class="c">// error</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-8">编译错误：</h3>
<blockquote>
  <p>./main.go:8:2: syntax error: unexpected ++, expecting }</p>
</blockquote>

<h3 id="正确示例-13">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="n">i</span><span class="o">++</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="28-取反操作符">28. 取反操作符</h2>
<ul>
  <li>等级： 初级</li>
</ul>

<p>很多语言使用<code class="language-plaintext highlighter-rouge">~</code>作为一元取反操作符（又名按位补足），但go复用了与或操作符<code class="language-plaintext highlighter-rouge">^</code>。</p>

<h3 id="错误示范-15">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="err">~</span><span class="m">2</span><span class="p">)</span> <span class="c">// expected operand, found 'ILLEGAL'</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="编译错误-9">编译错误：</h3>
<blockquote>
  <p>./main.go:6:14: invalid character U+007E ‘~’</p>
</blockquote>

<h3 id="正确示例-14">正确示例：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">d</span> <span class="kt">uint8</span> <span class="o">=</span> <span class="m">2</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">^</span><span class="n">d</span><span class="p">)</span> 
<span class="p">}</span>

</code></pre></div></div>

<p>go仍然使用<code class="language-plaintext highlighter-rouge">^</code>作为异或操作符，这可能让人感到困惑。
实际上你可以试试一元的非操作（例如，<code class="language-plaintext highlighter-rouge">NOT 0x02</code>）和二元的异或操作（例如，<code class="language-plaintext highlighter-rouge">0x02 XOR 0xff</code>）。这可以解释为什么<code class="language-plaintext highlighter-rouge">^</code>可以复用做一元非操作符。</p>

<p>go同时还有一个特殊的和非位操作付（<code class="language-plaintext highlighter-rouge">&amp;^</code>）,这可能增加非操作的困惑。这像是一个特殊的特性来支持<code class="language-plaintext highlighter-rouge">A AND (NOT B)</code>而不需要括号</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">a</span> <span class="kt">uint8</span> <span class="o">=</span> <span class="m">0x82</span>
    <span class="k">var</span> <span class="n">b</span> <span class="kt">uint8</span> <span class="o">=</span> <span class="m">0x02</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b [A]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b [B]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b (NOT B)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">^</span><span class="n">b</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b ^ %08b = %08b [B XOR 0xff]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="m">0xff</span><span class="p">,</span><span class="n">b</span> <span class="o">^</span> <span class="m">0xff</span><span class="p">)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b ^ %08b = %08b [A XOR B]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b &amp; %08b = %08b [A AND B]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b &amp;^%08b = %08b [A 'AND NOT' B]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">&amp;^</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%08b&amp;(^%08b)= %08b [A AND (NOT B)]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">^</span><span class="n">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="29-操作符优先级不同">29. 操作符优先级不同</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>除了”清除比特位”操作符(<code class="language-plaintext highlighter-rouge">&amp;^</code>)，go还有一些和其他很多语言一样的标准操作符。但操作符的优先级并不总是一样。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0x2 &amp; 0x2 + 0x4 -&gt; %#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="m">0x2</span> <span class="o">&amp;</span> <span class="m">0x2</span> <span class="o">+</span> <span class="m">0x4</span><span class="p">)</span>
    <span class="c">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span>
    <span class="c">//Go:    (0x2 &amp; 0x2) + 0x4</span>
    <span class="c">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="m">0x2</span> <span class="o">+</span> <span class="m">0x2</span> <span class="o">&lt;&lt;</span> <span class="m">0x1</span><span class="p">)</span>
    <span class="c">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span>
    <span class="c">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span>
    <span class="c">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0xf | 0x2 ^ 0x2 -&gt; %#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="m">0xf</span> <span class="o">|</span> <span class="m">0x2</span> <span class="o">^</span> <span class="m">0x2</span><span class="p">)</span>
    <span class="c">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span>
    <span class="c">//Go:    (0xf | 0x2) ^ 0x2</span>
    <span class="c">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="30-未导出的结构体字段不能被编解码">30. 未导出的结构体字段不能被编解码</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p>以小写字符开头结构体字段不能在json/xml/gob等中编码，所以当你解码时那些未导出的字段将赋予0值</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"encoding/json"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">MyData</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">One</span> <span class="kt">int</span>
    <span class="n">two</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">in</span> <span class="o">:=</span> <span class="n">MyData</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="s">"two"</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">in</span><span class="p">)</span> <span class="c">//prints main.MyData{One:1, two:"two"}</span>

    <span class="n">encoded</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">encoded</span><span class="p">))</span> <span class="c">//prints {"One":1}</span>

    <span class="k">var</span> <span class="n">out</span> <span class="n">MyData</span>
    <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">out</span><span class="p">)</span> <span class="c">//prints main.MyData{One:1, two:""}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="31-程序在活跃的协程时退出">31. 程序在活跃的协程时退出</h2>
<ul>
  <li>等级： 初级</li>
</ul>

<p>go程序不会等待所有的协程完成。这在初学者中是常犯的错误。每个人都有自己的起点，所以犯低级错误也没什么丢人的 :-)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">workerCount</span> <span class="o">:=</span> <span class="m">2</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workerCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">doit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"all done!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doit</span><span class="p">(</span><span class="n">workerId</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is running</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">workerId</span><span class="p">)</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">workerId</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>你将会看到：</p>
<blockquote>
  <p>[1] is running
[0] is running
all done!</p>
</blockquote>

<p>一个通常的解决方案是使用<code class="language-plaintext highlighter-rouge">WatiGroup</code>变量，它允许主协程等待知道所有的工作协程结束。处理循环时你也需要一个方法来通知其他协程是时候退出了。你可以发送一个kill消息给其他worker。另一个选择是关闭所有协程都在接受的通道。这是立刻通知所有协程的简单方式。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
    <span class="n">workerCount</span> <span class="o">:=</span> <span class="m">2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workerCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="n">doit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">done</span><span class="p">,</span><span class="n">wg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"all done!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doit</span><span class="p">(</span><span class="n">workerId</span> <span class="kt">int</span><span class="p">,</span><span class="n">done</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span><span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is running</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">workerId</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="o">&lt;-</span> <span class="n">done</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">workerId</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果你运行这个程序你可能会看到:</p>
<blockquote>
  <p>[1] is running
[1] is done
[0] is running
[0] is done
fatal error: all goroutines are asleep - deadlock!</p>

  <p>goroutine 1 [semacquire]:
sync.runtime_Semacquire(0xc0000140b8)
        /usr/local/go/src/runtime/sema.go:56 +0x45
sync.(*WaitGroup).Wait(0xc0000140b0)
        /usr/local/go/src/sync/waitgroup.go:130 +0x65
main.main()
        /home/zand/go/src/learn/gotchas/main.go:18 +0x105
exit status 2</p>
</blockquote>

<p>看起来工作协程都在主协程退出之前结束了。很棒，然而，你也会看到死锁的错误
这并不太妙 :-) 发生了什么？协程退出并且执行了<code class="language-plaintext highlighter-rouge">wg.Done()</code>.程序应该是工作的</p>

<p>死锁发生的原因是因为每个协程都获得了一份原始<code class="language-plaintext highlighter-rouge">WaitGroup</code>变量的拷贝。当协程执行<code class="language-plaintext highlighter-rouge">wg.Done()</code>时，对于主协程的<code class="language-plaintext highlighter-rouge">WaitGroup</code>变量没有作用。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"sync"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
    <span class="n">wq</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">interface</span><span class="p">{})</span>
    <span class="n">workerCount</span> <span class="o">:=</span> <span class="m">2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workerCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="n">doit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">wq</span><span class="p">,</span><span class="n">done</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workerCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wq</span> <span class="o">&lt;-</span> <span class="n">i</span>
    <span class="p">}</span>

    <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"all done!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">doit</span><span class="p">(</span><span class="n">workerId</span> <span class="kt">int</span><span class="p">,</span> <span class="n">wq</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">interface</span><span class="p">{},</span><span class="n">done</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{},</span><span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is running</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">workerId</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">m</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">wq</span><span class="o">:</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] m =&gt; %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">workerId</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">done</span><span class="o">:</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] is done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">workerId</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>现在它如预期般工作了</p>
<blockquote>
  <p>译者注，close channel后，会从channel中读出默认值</p>
</blockquote>

<h2 id="32-向无缓冲通道发送消息时一旦目标接受者准备好后会立刻返回">32 向无缓冲通道发送消息时，一旦目标接受者准备好后会立刻返回</h2>
<ul>
  <li>等级: 初级</li>
</ul>

<p>在你的消息被接收者处理之前，发送者不会被阻塞。接收方协程可能有或没有足够时间在发送方继续执行前来处理消息，这取决与你运行代码的机器。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"processed:"</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"cmd.1"</span>
    <span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"cmd.2"</span> <span class="c">// 不会打印出来</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="33-向已关闭的通道发送消息会导致panic">33 向已关闭的通道发送消息会导致panic</h2>
<ul>
  <li>等级： 初级</li>
</ul>

<p>从一个已关闭通道接收消息是安全的。在接收语句中<code class="language-plaintext highlighter-rouge">ok</code>返回的值将会是<code class="language-plaintext highlighter-rouge">false</code>来表示已经没有数据接收了。如果你从一个有缓冲通道接收，你将得到缓冲的数据，一旦缓冲通道里为空，<code class="language-plaintext highlighter-rouge">ok</code>将返回<code class="language-plaintext highlighter-rouge">false</code>.
向一个已关闭的通道发送数据将会带来panic。这是一种有记录的行为，但是对于萌新go开发者来说可能并不符合直觉，大家一般期望发送数据和接收数据的行为是相同的。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">idx</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ch</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="m">2</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">//get the first result</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
    <span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="c">//not ok (you still have other senders)</span>
    <span class="c">//do other work</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>根据你程序的不同修复方法也不一样。这可能是一个小的代码改动或者需要改变你程序的设计。不管怎样，你必须保证你的程序没有尝试向一个关闭的通道发送数据。</p>

<p>这个错误示例可以通过使用特殊的取消通道来通知剩下的协程他们的数据不在需要了来修复。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">idx</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="m">2</span><span class="o">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="s">"sent result"</span><span class="p">)</span>
            <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">done</span><span class="o">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="s">"exiting"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">//get first result</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result:"</span><span class="p">,</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
    <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
    <span class="c">//do other work</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="34-使用空通道">34 使用空通道</h2>
<ul>
  <li>等级：初级</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">nil</code>通道上的发送和接收操作永远是阻塞的。这是一个有据可查的行为，但是可能会惊讶到萌新的go开发者。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">idx</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ch</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="m">2</span>
        <span class="p">}(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">//get first result</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result:"</span><span class="p">,</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
    <span class="c">//do other work</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个特性可以用来动态打开和关闭<code class="language-plaintext highlighter-rouge">select</code>中<code class="language-plaintext highlighter-rouge">case</code>语句的方法</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>  
<span class="k">import</span> <span class="s">"time"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">inch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="n">outch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">in</span> <span class="o">&lt;-</span> <span class="k">chan</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">inch</span>
        <span class="k">var</span> <span class="n">out</span> <span class="k">chan</span> <span class="o">&lt;-</span> <span class="kt">int</span>
        <span class="k">var</span> <span class="n">val</span> <span class="kt">int</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">out</span> <span class="o">&lt;-</span> <span class="n">val</span><span class="o">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="no">nil</span>
                <span class="n">in</span> <span class="o">=</span> <span class="n">inch</span>
            <span class="k">case</span> <span class="n">val</span> <span class="o">=</span> <span class="o">&lt;-</span> <span class="n">in</span><span class="o">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">outch</span>
                <span class="n">in</span> <span class="o">=</span> <span class="no">nil</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">outch</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result:"</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
    <span class="n">inch</span> <span class="o">&lt;-</span> <span class="m">1</span>
    <span class="n">inch</span> <span class="o">&lt;-</span> <span class="m">2</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="35-值方法不能改变原始值">35 值方法不能改变原始值</h2>
<ul>
  <li>等级： 初级</li>
</ul>

<p>成员方法接收者和普通函数参数类似。如果定义为值那么你的函数或方法会得到一个接收者参数的copy。这意味着对接收者的改变不会影响到原始值除非你的接收者是一个字典或者切片并且你在集合中更新他们的项,或者你要更新的字段在接收者中是指针。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">num</span> <span class="kt">int</span>
    <span class="n">key</span> <span class="o">*</span><span class="kt">string</span>
    <span class="n">items</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="n">pmethod</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">this</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="m">7</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">this</span> <span class="n">data</span><span class="p">)</span> <span class="n">vmethod</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">this</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="m">8</span>
    <span class="o">*</span><span class="n">this</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="s">"v.key"</span>
    <span class="n">this</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="s">"vmethod"</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">key</span> <span class="o">:=</span> <span class="s">"key.1"</span>
    <span class="n">d</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num=%v key=%v items=%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">num</span><span class="p">,</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">key</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
    <span class="c">//prints num=1 key=key.1 items=map[]</span>

    <span class="n">d</span><span class="o">.</span><span class="n">pmethod</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num=%v key=%v items=%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">num</span><span class="p">,</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">key</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> 
    <span class="c">//prints num=7 key=key.1 items=map[]</span>

    <span class="n">d</span><span class="o">.</span><span class="n">vmethod</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"num=%v key=%v items=%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">num</span><span class="p">,</span><span class="o">*</span><span class="n">d</span><span class="o">.</span><span class="n">key</span><span class="p">,</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
    <span class="c">//prints num=7 key=v.key items=map[vmethod:true]</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="36-关闭http返回体">36 关闭HTTP返回体</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>当你使用标准库的http包来构造请求时你会得到一个http返回变量。即使你不去读这个返回体你也需要去关闭它。需要注意对于空返回你也必须这么做。对于萌新go开发者来说这特别容易忘记</p>

<p>有些新人尝试去关闭返回体，却在错误的地方操作的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
    <span class="s">"io/ioutil"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"https://api.ipify.org?format=json"</span><span class="p">)</span>
    <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="c">//using resp before checking for errors</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
</code></pre></div></div>
<p>这段代码在成功请求的时候是没问题的，但是如果http请求失败，<code class="language-plaintext highlighter-rouge">resp</code>变量可能会是<code class="language-plaintext highlighter-rouge">nil</code>，这将会引起panic。</p>

<p>更常用的方法是在http请求错误检查之后使用<code class="language-plaintext highlighter-rouge">defer</code>语句关闭请求体。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
    <span class="s">"io/ioutil"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"https://api.ipify.org?format=json"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="c">//ok, most of the time :-)</span>
    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>大多数时间你的http请求失败后<code class="language-plaintext highlighter-rouge">resp</code>变量会是<code class="language-plaintext highlighter-rouge">nil</code>并且<code class="language-plaintext highlighter-rouge">err</code>变量会是非空。然而，当你得到重定向错误的时候这两个变量都是非空的。这意味着你仍然会有内存泄露。</p>

<p>你可以通过在http返回错误处理代码中增加关闭非空返回体的调用来修复这个泄露。其他的选择是使用<code class="language-plaintext highlighter-rouge">defer</code>语句在所有成功和失败的情况下来关闭返回体</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
    <span class="s">"io/ioutil"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"https://api.ipify.org?format=json"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resp</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">resp.Body.Close()</code>原始的实现中同时会读取和丢弃剩余的返回体数据。这将保证如果允许保持http链接的话，http链接能够被其他请求重用。最新版本的http客户端行为不一样。现在你的你需要自己来读取和丢弃剩余的相应数据。如果你不做那么http链接可能会直接关闭而不是重用。这个小问题在go1.5的文档中记载。</p>

<p>如果在你的程序中复用http链接是非常重要的事，你可能需要在你结束处理返回的逻辑上加上如下代码</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">ioutil</span><span class="o">.</span><span class="n">Discard</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
</code></pre></div></div>
<p>如果你没有正确的读取整个返回体，这很有必要，这在你处理json api的时候有可能发生。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">json</span><span class="o">.</span><span class="n">NewDecoder</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="37-关闭http链接">37 关闭http链接</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>一些HTTP服务器会保持网络连接一会（在http1.1且服务器”keep-alive”选项开启的情况下）。默认情况下，http标准库只有在目标http服务器请求的时候才会关闭网络连接。这意味着你的程序可能在某些情况下耗尽套接字、文件描述符。</p>

<p>你可以让http库在你的请求结束后关闭请求，蛇者请求体的<code class="language-plaintext highlighter-rouge">Close</code>字段为<code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>另外的选择是添加一个<code class="language-plaintext highlighter-rouge">Connection</code>的请求头并且设置为<code class="language-plaintext highlighter-rouge">close</code>.目标HTTP服务也需要返回一个<code class="language-plaintext highlighter-rouge">Connection:close</code>头。当http库看到这个返回头将会关闭链接</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
    <span class="s">"io/ioutil"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">req</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">NewRequest</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span><span class="s">"http://golang.org"</span><span class="p">,</span><span class="no">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">req</span><span class="o">.</span><span class="n">Close</span> <span class="o">=</span> <span class="no">true</span>
    <span class="c">//or do this:</span>
    <span class="c">//req.Header.Add("Connection", "close")</span>

    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">DefaultClient</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resp</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你也可以全局的禁止http链接重用。你需要创建一个自定义的http传输配置。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
    <span class="s">"io/ioutil"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">tr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">http</span><span class="o">.</span><span class="n">Transport</span><span class="p">{</span><span class="n">DisableKeepAlives</span><span class="o">:</span> <span class="no">true</span><span class="p">}</span>
    <span class="n">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">http</span><span class="o">.</span><span class="n">Client</span><span class="p">{</span><span class="n">Transport</span><span class="o">:</span> <span class="n">tr</span><span class="p">}</span>

    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"http://golang.org"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resp</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">StatusCode</span><span class="p">)</span>

    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">body</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你向一个HTTP服务器发送大量请求，那么保持网络链接也是OK的。然而，如果你的程序在短时间内向很多不同的HTTP服务器发送一到两个请求，那么在你的程序接收到返回后立刻关闭网络请求是个好主意。或者增加打开的文件限制。正确的解决方案取决于你的程序（的应用场景？译者注）。</p>

<h2 id="38-json-编码增加回车符">38. JSON 编码增加回车符</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>你正在编写一个针对你JSON编码函数的测试，当你发现你的测试失败了，是因为没有获得预期的值。发生了什么？如果你使用JSON编码对象你将得到一个额外的新行字符在你的编码后的JSON对象的末尾。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"encoding/json"</span>
  <span class="s">"bytes"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">"key"</span><span class="o">:</span> <span class="m">1</span><span class="p">}</span>
  
  <span class="k">var</span> <span class="n">b</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
  <span class="n">json</span><span class="o">.</span><span class="n">NewEncoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">Encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="n">raw</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  
  <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">String</span><span class="p">()</span> <span class="o">==</span> <span class="kt">string</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"same encoded data"</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"'%s' != '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">raw</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
    <span class="c">//prints:</span>
    <span class="c">//'{"key":1}' != '{"key":1}\n'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>JSON编码对象为了流式设计的。JSON流通常意味着用新行分割JSON对象，这是为什么编码方法会增加一个新行字符。这也是有记载的行为，但通常容易被忽视和忘记。</p>

<h2 id="39-json-包会转译特殊的html字符在关键字和字符串">39 JSON 包会转译特殊的HTML字符在关键字和字符串</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>这也是个有记录的行为，但你需要仔细的阅读所有JSON包的文档才学到它。<code class="language-plaintext highlighter-rouge">SetEscapeHTML</code>的方法描述讨论了字符但不仅仅是字符的默认的编码行为。
从很多方面来讲这是go团队一个非常不成功的决定。第一，你不能在<code class="language-plaintext highlighter-rouge">json.Marshal</code>函数中禁止这个行为。第二，这是一个实现的很糟糕的安全特性因为它假设HTML编码足够保护XSS漏洞在所有的网络应用中。数据可以用到大量的不同的上下文，每个上下文都需要自己的编码方法。最后，它很糟糕因为它假设JSON的主要应用是网页，默认情况下会破坏配置库和RESP/HTTP的APIs。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"encoding/json"</span>
  <span class="s">"bytes"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">data</span> <span class="o">:=</span> <span class="s">"x &lt; y"</span>
  
  <span class="n">raw</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span>
  <span class="c">//prints: "x \u003c y" &lt;- probably not what you expected</span>
  
  <span class="k">var</span> <span class="n">b1</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
  <span class="n">json</span><span class="o">.</span><span class="n">NewEncoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b1</span><span class="p">)</span><span class="o">.</span><span class="n">Encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
  <span class="c">//prints: "x \u003c y" &lt;- probably not what you expected</span>
  
  <span class="k">var</span> <span class="n">b2</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span>
  <span class="n">enc</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">NewEncoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b2</span><span class="p">)</span>
  <span class="n">enc</span><span class="o">.</span><span class="n">SetEscapeHTML</span><span class="p">(</span><span class="no">false</span><span class="p">)</span>
  <span class="n">enc</span><span class="o">.</span><span class="n">Encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
  <span class="c">//prints: "x &lt; y" &lt;- looks better</span>
<span class="p">}</span>
</code></pre></div></div>
<p>给go团队提一个建议…做成可选的吧。</p>

<h2 id="40-解码json的数字到接口值">40 解码JSON的数字到接口值</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>默认情况下，在你编解码JSON数据到接口时go将JSON中的数值当做<code class="language-plaintext highlighter-rouge">float64</code>类型。这意味着下面的代码将会引起panic:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
  <span class="s">"encoding/json"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"status": 200}`</span><span class="p">)</span>

  <span class="k">var</span> <span class="n">result</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error:"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="n">status</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s">"status"</span><span class="p">]</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c">//error</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"status value:"</span><span class="p">,</span><span class="n">status</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Runtime Panic:</p>
<blockquote>
  <p>panic:interface conversion: interface is float64, not int
如果你尝试解码的JSON值是数字，你可以尝试以下几种方法。
1：使用原本的float值 :-)
2: 将float值转换为你需要的int类型
```go
package main</p>
</blockquote>

<p>import (<br />
  “encoding/json”
  “fmt”
)</p>

<p>func main() {<br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p>

<p>var result map[string]interface{}
  if err := json.Unmarshal(data, &amp;result); err != nil {
    fmt.Println(“error:”, err)
    return
  }</p>

<p>var status = uint64(result[“status”].(float64)) //ok
  fmt.Println(“status value:”,status)
}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3: 使用`Decoder`来解码JSON并且告知将JSON数字使用`Number`接口类型

```go
package main

import (  
  "encoding/json"
  "bytes"
  "fmt"
)

func main() {  
  var data = []byte(`{"status": 200}`)

  var result map[string]interface{}
  var decoder = json.NewDecoder(bytes.NewReader(data))
  decoder.UseNumber()

  if err := decoder.Decode(&amp;result); err != nil {
    fmt.Println("error:", err)
    return
  }

  var status,_ = result["status"].(json.Number).Int64() //ok
  fmt.Println("status value:",status)
}
</code></pre></div></div>

<p>你可以使用字符串代表数值来解码到不同的数值类型：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
  <span class="s">"encoding/json"</span>
  <span class="s">"bytes"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"status": 200}`</span><span class="p">)</span>

  <span class="k">var</span> <span class="n">result</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}</span>
  <span class="k">var</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">NewDecoder</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">decoder</span><span class="o">.</span><span class="n">UseNumber</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error:"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="n">status</span> <span class="kt">uint64</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s">"status"</span><span class="p">]</span><span class="o">.</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span><span class="o">.</span><span class="n">String</span><span class="p">()),</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error:"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"status value:"</span><span class="p">,</span><span class="n">status</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>4: 使用<code class="language-plaintext highlighter-rouge">struct</code> 类型映射你的数值到数值类型。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
  <span class="s">"encoding/json"</span>
  <span class="s">"bytes"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"status": 200}`</span><span class="p">)</span>

  <span class="k">var</span> <span class="n">result</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Status</span> <span class="kt">uint64</span> <span class="s">`json:"status"`</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">NewDecoder</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error:"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"result =&gt; %+v"</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
  <span class="c">//prints: result =&gt; {Status:200}</span>
<span class="p">}</span>
</code></pre></div></div>
<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">struct</code>映射你的数值到<code class="language-plaintext highlighter-rouge">json.RawMessage</code>类型如果你需要延迟解码。</li>
</ol>

<p>如果你执行有条件的JSON字段解码，字段类型和结构可能改变时这个方法很有用。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
  <span class="s">"encoding/json"</span>
  <span class="s">"bytes"</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
  <span class="n">records</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span>
    <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"status": 200, "tag":"one"}`</span><span class="p">),</span>
    <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"status":"ok", "tag":"two"}`</span><span class="p">),</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">record</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">records</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">result</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="n">StatusCode</span> <span class="kt">uint64</span>
      <span class="n">StatusName</span> <span class="kt">string</span>
      <span class="n">Status</span> <span class="n">json</span><span class="o">.</span><span class="n">RawMessage</span> <span class="s">`json:"status"`</span>
      <span class="n">Tag</span> <span class="kt">string</span>             <span class="s">`json:"tag"`</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">NewDecoder</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">record</span><span class="p">))</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error:"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="n">sstatus</span> <span class="kt">string</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">Status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">result</span><span class="o">.</span><span class="n">StatusName</span> <span class="o">=</span> <span class="n">sstatus</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="n">nstatus</span> <span class="kt">uint64</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">Status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nstatus</span><span class="p">);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="n">result</span><span class="o">.</span><span class="n">StatusCode</span> <span class="o">=</span> <span class="n">nstatus</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"[%v] result =&gt; %+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="41-包含十六进制或其他非utf8转义序列的json字符串值可能不是预期的">41 包含十六进制或其他非UTF8转义序列的JSON字符串值可能不是预期的</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>go预期字符串值都是UTF8编码的。这意味着你不能有任何十六进制转义二进制数据在你的JSON字符串里（并且你仍然需要转义反斜杠）。这是go遗传下来的一个坑，但是它在go程序中发生的足够频繁，因此提及它仍然是有意义的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"encoding/json"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">config</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Data</span> <span class="kt">string</span> <span class="s">`json:"data"`</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">raw</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"data":"\xc2"}`</span><span class="p">)</span>
  <span class="k">var</span> <span class="n">decoded</span> <span class="n">config</span>

  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">decoded</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="c">//prints: invalid character 'x' in string escape code</span>
    <span class="p">}</span>
  
<span class="p">}</span>
</code></pre></div></div>

<p>Unmarshal或者Decode 都会失败如果go发现有十六进制的转义序列。如果你确实需要在你的字符串中加入反斜杠，记得用另一个反斜杠转义它。如果你想使用十六进制编码二进制数据你可以转义反斜杠然后做你自己的十六进制转义。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"encoding/json"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">config</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Data</span> <span class="kt">string</span> <span class="s">`json:"data"`</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">raw</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"data":"\\xc2"}`</span><span class="p">)</span>
  
  <span class="k">var</span> <span class="n">decoded</span> <span class="n">config</span>
  
  <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">decoded</span><span class="p">)</span>
  
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#v"</span><span class="p">,</span><span class="n">decoded</span><span class="p">)</span> <span class="c">//prints: main.config{Data:"\\xc2"}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另一个选择是使用byte数组/切片数据类型在你的JSON对象，但是二进制数据必须是base64编码</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
  <span class="s">"encoding/json"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">config</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Data</span> <span class="p">[]</span><span class="kt">byte</span> <span class="s">`json:"data"`</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">raw</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">`{"data":"wg=="}`</span><span class="p">)</span>
  <span class="k">var</span> <span class="n">decoded</span> <span class="n">config</span>
  
  <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">decoded</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
      <span class="p">}</span>
  
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%#v"</span><span class="p">,</span><span class="n">decoded</span><span class="p">)</span> <span class="c">//prints: main.config{Data:[]uint8{0xc2}}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>其他需要注意的是Unicode替换字符(U+FFFD)。Go将使用替换字符而不是无效的UTF8，因此Unmarshal/Decode调用不会失败，但您得到的字符串值可能不是您所期望的。</p>

<h2 id="42-比较结构体数组切片和字典">42 比较结构体、数组、切片和字典</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>你可以使用相等运算符, <code class="language-plaintext highlighter-rouge">==</code>, 来比较结构体变量，如果结构体的每个字段都可以用相等运算符比较的话。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">num</span> <span class="kt">int</span>
    <span class="n">fp</span> <span class="kt">float32</span>
    <span class="nb">complex</span> <span class="kt">complex64</span>
    <span class="n">str</span> <span class="kt">string</span>
    <span class="n">char</span> <span class="kt">rune</span>
    <span class="n">yes</span> <span class="kt">bool</span>
    <span class="n">events</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">string</span>
    <span class="n">handler</span> <span class="k">interface</span><span class="p">{}</span>
    <span class="n">ref</span> <span class="o">*</span><span class="kt">byte</span>
    <span class="n">raw</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">v1</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">v2</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v1 == v2:"</span><span class="p">,</span><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">)</span> <span class="c">//prints: v1 == v2: true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果任意一个结构体字段不是可比较的，那么使用比较操作符就会导致运行时错误。需要注意数组只有在其元素是可比较的情况下才是可比较的。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">num</span> <span class="kt">int</span>                <span class="c">//ok</span>
    <span class="n">checks</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="c">//not comparable</span>
    <span class="n">doit</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span>       <span class="c">//not comparable</span>
    <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="kt">string</span>   <span class="c">//not comparable</span>
    <span class="n">bytes</span> <span class="p">[]</span><span class="kt">byte</span>           <span class="c">//not comparable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">v1</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">v2</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v1 == v2:"</span><span class="p">,</span><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// ./main.go:16:30: invalid operation: v1 == v2 (struct containing [10]func() bool cannot be compared)</span>
</code></pre></div></div>
<p>go提供了一系列的帮助函数来比较那些不能使用比较运算符来比较的变量。</p>

<p>最通用的解决方案是使用反射包里的<code class="language-plaintext highlighter-rouge">DeepEqual()</code>函数</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"reflect"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">num</span> <span class="kt">int</span>                <span class="c">//ok</span>
    <span class="n">checks</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span><span class="k">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="c">//not comparable</span>
    <span class="n">doit</span> <span class="k">func</span><span class="p">()</span> <span class="kt">bool</span>       <span class="c">//not comparable</span>
    <span class="n">m</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="kt">string</span>   <span class="c">//not comparable</span>
    <span class="n">bytes</span> <span class="p">[]</span><span class="kt">byte</span>           <span class="c">//not comparable</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">v1</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">v2</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v1 == v2:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">))</span> <span class="c">//prints: v1 == v2: true</span>

    <span class="n">m1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="o">:</span> <span class="s">"a"</span><span class="p">,</span><span class="s">"two"</span><span class="o">:</span> <span class="s">"b"</span><span class="p">}</span>
    <span class="n">m2</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"two"</span><span class="o">:</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"one"</span><span class="o">:</span> <span class="s">"a"</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"m1 == m2:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">))</span> <span class="c">//prints: m1 == m2: true</span>

    <span class="n">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
    <span class="n">s2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"s1 == s2:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span> <span class="c">//prints: s1 == s2: true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>除了速度慢之外(这对你的程序来说可能是重要的点)，<code class="language-plaintext highlighter-rouge">DeepEqual()</code>还有别的坑。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"reflect"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">b1</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="n">b2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"b1 == b2:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span> <span class="c">//prints: b1 == b2: false</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">DeepEqual()</code>不认为一个空切片和nil切片相等。这和你使用<code class="language-plaintext highlighter-rouge">bytes.Equal()</code>函数得出的结果不一样，<code class="language-plaintext highlighter-rouge">bytes.Equal()</code>认为nil和空切片是相同的。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"bytes"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">b1</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="no">nil</span>
    <span class="n">b2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"b1 == b2:"</span><span class="p">,</span><span class="n">bytes</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">))</span> <span class="c">//prints: b1 == b2: true</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">DeepEqual()</code>在比较切片的时候并不总是完美的</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"reflect"</span>
    <span class="s">"encoding/json"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">str</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">"one"</span>
    <span class="k">var</span> <span class="n">in</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"one"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"str == in:"</span><span class="p">,</span><span class="n">str</span> <span class="o">==</span> <span class="n">in</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">in</span><span class="p">))</span> 
    <span class="c">//prints: str == in: true true</span>

    <span class="n">v1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">}</span>
    <span class="n">v2</span> <span class="o">:=</span> <span class="p">[]</span><span class="k">interface</span><span class="p">{}{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"v1 == v2:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> 
    <span class="c">//prints: v1 == v2: false (not ok)</span>

    <span class="n">data</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}{</span>
        <span class="s">"code"</span><span class="o">:</span> <span class="m">200</span><span class="p">,</span>
        <span class="s">"value"</span><span class="o">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">},</span>
    <span class="p">}</span>
    <span class="n">encoded</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">var</span> <span class="n">decoded</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}</span>
    <span class="n">json</span><span class="o">.</span><span class="n">Unmarshal</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">decoded</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"data == decoded:"</span><span class="p">,</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">decoded</span><span class="p">))</span> 
    <span class="c">//prints: data == decoded: false (not ok)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你需要忽略大小写（在使用<code class="language-plaintext highlighter-rouge">==</code>,<code class="language-plaintext highlighter-rouge">bytes.Equal()</code>,<code class="language-plaintext highlighter-rouge">bytes.Compare()</code>之前）来比较文本byte切片（或者字符串），你需要尝试使用”bytes”和”strings”包里的<code class="language-plaintext highlighter-rouge">ToUpper()</code>或者<code class="language-plaintext highlighter-rouge">ToLower()</code>。这在英文下OK，但在很多其他语言中可能不行。最好使用<code class="language-plaintext highlighter-rouge">strings.EqualFold()</code>或者<code class="language-plaintext highlighter-rouge">bytes.EqualFold()</code>来代替。</p>

<p>如果你的byte slices包含密文(比如密文哈希，tokens，等)需要验证用户提交的数据，不要使用<code class="language-plaintext highlighter-rouge">reflect.DeepEqual()</code>，<code class="language-plaintext highlighter-rouge">bytes.Equal()</code>，或者<code class="language-plaintext highlighter-rouge">bytes.Compare</code>因为这些函数将会使你的程序易于被<strong>时序攻击</strong>。为了避免泄露时间信息需要使用<code class="language-plaintext highlighter-rouge">crypto/subtle</code>包里的函数(比如<code class="language-plaintext highlighter-rouge">subtle.ConstanTimeCompare()</code>).</p>

<h2 id="43-从panic中恢复">43 从panic中恢复</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">recover()</code>函数可以用于抓住、拦截一个panic.但只有在一个延迟函数中调用<code class="language-plaintext highlighter-rouge">recover()</code>才能达到这个目的</p>

<p>不正确的：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">recover</span><span class="p">()</span> <span class="c">// doesn't do anything</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">"not good"</span><span class="p">)</span>
    <span class="nb">recover</span><span class="p">()</span> <span class="c">// won't be executed :)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"ok"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>正确的：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt:

func main() {
    defer func() {
        fmt.Println("</span><span class="n">recoverd</span><span class="o">:</span><span class="s">", recover())
    }()
    panic("</span><span class="n">not</span> <span class="n">good</span><span class="s">")
}
</span></code></pre></div></div>
<p>对<code class="language-plaintext highlighter-rouge">recover()</code>的调用只有在你的延迟函数中直接调用时才能生效</p>

<p>错误示范：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">doRecover</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"recovered =&gt;"</span><span class="p">,</span><span class="nb">recover</span><span class="p">())</span> <span class="c">//prints: recovered =&gt; &lt;nil&gt;</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">doRecover</span><span class="p">()</span> <span class="c">//panic is not recovered</span>
    <span class="p">}()</span>

    <span class="nb">panic</span><span class="p">(</span><span class="s">"not good"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="44-在slicearraymap的range语句中更新和引用元素">44 在slice/array/map的range语句中更新和引用元素</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>在<code class="language-plaintext highlighter-rouge">range</code>语句中生成的数据是实际元素集合的拷贝。并不是指向原始数据。这意味着更新数据不饿能改变原始数据。同时意味着获取数据的地址不会给你原始数据的指针。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">*=</span> <span class="m">10</span> <span class="c">//original item is not changed</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"data:"</span><span class="p">,</span><span class="n">data</span><span class="p">)</span> <span class="c">//prints data: [1 2 3]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你需要更新原始的集合记录值，需要使用索引来访问数据。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="m">10</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"data:"</span><span class="p">,</span><span class="n">data</span><span class="p">)</span> <span class="c">//prints data: [10 20 30]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你的集合包括指针，那么规则有些许不同，你仍然需要使用指针来使你的原始数据指向其他值，但是你可以更新<code class="language-plaintext highlighter-rouge">for range</code>语句第二个值指向的数据</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
	<span class="n">a</span> <span class="o">:=</span> <span class="k">struct</span><span class="p">{</span> <span class="n">num</span> <span class="kt">int</span> <span class="p">}{</span><span class="m">1</span><span class="p">}</span>
	<span class="n">b</span> <span class="o">:=</span> <span class="k">struct</span><span class="p">{</span> <span class="n">num</span> <span class="kt">int</span> <span class="p">}{</span><span class="m">2</span><span class="p">}</span>
	<span class="n">c</span> <span class="o">:=</span> <span class="k">struct</span><span class="p">{</span> <span class="n">num</span> <span class="kt">int</span> <span class="p">}{</span><span class="m">3</span><span class="p">}</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="k">struct</span><span class="p">{</span> <span class="n">num</span> <span class="kt">int</span> <span class="p">}{</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">v</span><span class="o">.</span><span class="n">num</span> <span class="o">*=</span> <span class="m">10</span>
    <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">],</span><span class="n">data</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="n">data</span><span class="p">[</span><span class="m">2</span><span class="p">])</span> <span class="c">//prints &amp;{10} &amp;{20} &amp;{30}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="45-在切片中隐藏数据">45 在切片中隐藏数据</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>当你对一个切片重新切片，新切片仍然指向原始切片的数组。如果你不记得这种行为，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，可能导致不可预料的内存使用问题。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">get</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="n">raw</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="m">10000</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">raw</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>	<span class="c">// 10000 10000 0xc420080000</span>
	<span class="k">return</span> <span class="n">raw</span><span class="p">[</span><span class="o">:</span><span class="m">3</span><span class="p">]</span>	<span class="c">// 重新分配容量为 10000 的 slice</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">data</span> <span class="o">:=</span> <span class="n">get</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>	<span class="c">// 3 10000 0xc420080000</span>
<span class="p">}</span>
</code></pre></div></div>
<p>为了避免这个陷阱，可以拷贝数据而不是重新切片</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">get</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>  
    <span class="n">raw</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="m">10000</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span><span class="o">&amp;</span><span class="n">raw</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">//prints: 10000 10000 0xc0000c0000</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="m">3</span><span class="p">)</span>
    <span class="nb">copy</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">raw</span><span class="p">[</span><span class="o">:</span><span class="m">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="n">get</span><span class="p">()</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c">//prints: 3 3 0xc0000b8028</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="46-切片数据损坏">46 切片数据”损坏”</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>比如说你要重写一个存储在切片里的路径。你重新切片了这个路径,然后修改了第一个文件夹名字然后组合名字创建新的路径</p>
<blockquote>
  <p>译者注: 读英文博客/书的时候总发现举例写的太绕了, 感觉可能是文化的不同, 外文的例子或梗很难get到. 请直接看代码来理解吧</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"bytes"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"AAAA/BBBBBBBBB"</span><span class="p">)</span>
    <span class="n">sepIndex</span> <span class="o">:=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">IndexByte</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="sc">'/'</span><span class="p">)</span>
    <span class="n">dir1</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="o">:</span><span class="n">sepIndex</span><span class="p">]</span>
    <span class="n">dir2</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="n">sepIndex</span><span class="o">+</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir1 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span> <span class="c">//prints: dir1 =&gt; AAAA</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir2 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span> <span class="c">//prints: dir2 =&gt; BBBBBBBBB</span>

    <span class="n">dir1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span><span class="s">"suffix"</span><span class="o">...</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Join</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">{</span><span class="n">dir1</span><span class="p">,</span><span class="n">dir2</span><span class="p">},[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">'/'</span><span class="p">})</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir1 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span> <span class="c">//prints: dir1 =&gt; AAAAsuffix</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir2 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span> <span class="c">//prints: dir2 =&gt; uffixBBBB (not ok)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"new path =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>并不是想你预期的那样，你得到是”AAAsuffix/uffixBBBB”而不是”AAAAsuffix/BBBBBBBB”。这种情况发生的原因是因为所有的目录切片都指向了原来路径切片的底层数组。这意味着原来的路径也同样被改变了。这对你的应用来说应该也是个问题。</p>

<p>修复该问题的方法是分配一个新的切片并拷贝你需要的数据。另一个选择是使用完整的切片表达式</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"bytes"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">path</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"AAAA/BBBBBBBBB"</span><span class="p">)</span>
    <span class="n">sepIndex</span> <span class="o">:=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">IndexByte</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="sc">'/'</span><span class="p">)</span>
    <span class="n">dir1</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="o">:</span><span class="n">sepIndex</span><span class="o">:</span><span class="n">sepIndex</span><span class="p">]</span> <span class="c">//full slice expression</span>
    <span class="n">dir2</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="n">sepIndex</span><span class="o">+</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir1 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span> <span class="c">//prints: dir1 =&gt; AAAA</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir2 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span> <span class="c">//prints: dir2 =&gt; BBBBBBBBB</span>

    <span class="n">dir1</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span><span class="s">"suffix"</span><span class="o">...</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">Join</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">{</span><span class="n">dir1</span><span class="p">,</span><span class="n">dir2</span><span class="p">},[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">'/'</span><span class="p">})</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir1 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir1</span><span class="p">))</span> <span class="c">//prints: dir1 =&gt; AAAAsuffix</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"dir2 =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">dir2</span><span class="p">))</span> <span class="c">//prints: dir2 =&gt; BBBBBBBBB (ok now)</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"new path =&gt;"</span><span class="p">,</span><span class="kt">string</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>完整切片表达式的额外参数控制着新切片的容量。现在向这个切片追加数据将会触发新的内存分配而不是覆盖第二个切片的数据。</p>

<blockquote>
  <p>译者注：这是个比较典型的问题，读者务必亲手实践感受下</p>
</blockquote>

<h2 id="47-变味的切片">47 “变味的”切片</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>多个切片可能指向相同的数据。这往往由于你从一个已经存在的切片来创造一个新的切片。如果你的程序中依赖这种行为来正常工作，那么你需要担心“变味的”切片。</p>

<p>在某个点对其中一个切片增加数据可能导致新的数组分配，当原始数组不能放更多新数据的时候。现在其他的切片将指向旧的数组。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span><span class="n">s1</span><span class="p">)</span> <span class="c">//prints 3 3 [1 2 3]</span>

    <span class="n">s2</span> <span class="o">:=</span> <span class="n">s1</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="n">s2</span><span class="p">),</span><span class="n">s2</span><span class="p">)</span> <span class="c">//prints 2 2 [2 3]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s2</span> <span class="p">{</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="m">20</span> <span class="p">}</span>

    <span class="c">//still referencing the same array</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="c">//prints [1 22 23]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="c">//prints [22 23]</span>

    <span class="n">s2</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="m">4</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s2</span> <span class="p">{</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="m">10</span> <span class="p">}</span>

    <span class="c">//s1 is now "stale"</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="c">//prints [1 22 23]</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="c">//prints [32 33 14]</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>译者注 跟46讲的其实是一回事</p>
</blockquote>

<h2 id="48-类型声明和方法">48 类型声明和方法</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>当你通过从已经存在的类型定义新类型的方式创建新的类型声明时，你没有继承已存在类型的方法定义。</p>

<h3 id="错误示例">错误示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sync"</span>

<span class="k">type</span> <span class="n">myMutex</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">mtx</span> <span class="n">myMutex</span>
    <span class="n">mtx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">//mtx.Lock undefined (type myMutex has no field or method Lock)</span>
    <span class="n">mtx</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">//mtx.Unlock undefined (type myMutex has no field or method Unlock) </span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译错误-10">编译错误</h3>
<blockquote>
  <p>./main.go:9:5: mtx.Lock undefined (type myMutex has no field or method Lock) 
./main.go:10:5: mtx.Unlock undefined (type myMutex has no field or method Unlock)</p>
</blockquote>

<p>如果你需要原始类型的方法，你可以定义一个新的结构体类型将原始类型作为匿名字段嵌入进来。</p>

<h3 id="正确示范">正确示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sync"</span>

<span class="k">type</span> <span class="n">myLocker</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">lock</span> <span class="n">myLocker</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">//ok</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">//ok</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接口类型的声明也会保留它们的方法</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"sync"</span>

<span class="k">type</span> <span class="n">myLocker</span> <span class="n">sync</span><span class="o">.</span><span class="n">Locker</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">lock</span> <span class="n">myLocker</span> <span class="o">=</span> <span class="nb">new</span><span class="p">(</span><span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span><span class="p">)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c">//ok</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span> <span class="c">//ok</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="49-从for-switch或for-select代码块中退出">49 从<code class="language-plaintext highlighter-rouge">for switch</code>或<code class="language-plaintext highlighter-rouge">for select</code>代码块中退出</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>没有标签的<code class="language-plaintext highlighter-rouge">break</code>语句只会使你跳出内部switch/select代码块。如果不使用<code class="language-plaintext highlighter-rouge">return</code>语句，那么在外层循环中定义一个标签是另一个好办法。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">loop</span><span class="o">:</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">{</span>
            <span class="k">case</span> <span class="no">true</span><span class="o">:</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"breaking out..."</span><span class="p">)</span>
                <span class="k">break</span> <span class="n">loop</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"out!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">goto</code>语句也会做同样的事情</p>

<h2 id="50-for语句中的迭代变量和闭包">50 <code class="language-plaintext highlighter-rouge">for</code>语句中的迭代变量和闭包</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>这是go中最常见的陷阱。<code class="language-plaintext highlighter-rouge">for</code> 语句中的迭代变量在每次迭代中都会复用。这意味着在你的<code class="language-plaintext highlighter-rouge">for</code>循环中创建的每次闭包（又名字面函数）将指向同一个变量（他们得到这个变量值在他们的协程开始执行时候的值）</p>

<h3 id="错误示范-16">错误示范</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">,</span><span class="s">"three"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="c">//goroutines print: three, three, three</span>
<span class="p">}</span>
</code></pre></div></div>
<p>最简单的解决方法（对协程不需要做任何修改）是在<code class="language-plaintext highlighter-rouge">for</code>循环中保存当前迭代变量到本地变量。</p>

<h3 id="正确示例-15">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">,</span><span class="s">"three"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">vcopy</span> <span class="o">:=</span> <span class="n">v</span> <span class="c">//</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">vcopy</span><span class="p">)</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="c">//goroutines print: one, two, three</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另一个解决方案是将当前迭代值作为参数传递到协程中</p>
<h3 id="正确示例-16">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">,</span><span class="s">"three"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">in</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>
        <span class="p">}(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="c">//goroutines print: one, two, three</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里再给一个关于这个陷阱的稍微复杂的版本。</p>
<h3 id="错误示范-17">错误示范</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">field</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">field</span><span class="p">{{</span><span class="s">"one"</span><span class="p">},{</span><span class="s">"two"</span><span class="p">},{</span><span class="s">"three"</span><span class="p">}}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">v</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="c">//goroutines print: three, three, three</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="正确示例-17">正确示例</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">field</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">field</span><span class="p">{{</span><span class="s">"one"</span><span class="p">},{</span><span class="s">"two"</span><span class="p">},{</span><span class="s">"three"</span><span class="p">}}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="n">v</span> <span class="o">:=</span> <span class="n">v</span>
        <span class="k">go</span> <span class="n">v</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
    <span class="c">//goroutines print: one, two, three</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你认为执行以下代码会发生什么（以及为什么）？</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">field</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">field</span><span class="p">)</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="n">field</span><span class="p">{{</span><span class="s">"one"</span><span class="p">},{</span><span class="s">"two"</span><span class="p">},{</span><span class="s">"three"</span><span class="p">}}</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">data</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">v</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">3</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>译者注：此时v是指针，可以正确输出</p>
</blockquote>

<h2 id="51-调用defer函数的参数">51 调用defer函数的参数</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>defer函数的参数在<code class="language-plaintext highlighter-rouge">defer</code>语句声明时就计算而不是函数实际执行时。同样的规则也适用于defer方法调用。结构值也会与显式方法参数和闭变量一起保存。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">i</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">1</span>

    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result =&gt;"</span><span class="p">,</span><span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="m">2</span> <span class="p">}())</span>
    <span class="n">i</span><span class="o">++</span>
    <span class="c">//prints: result =&gt; 2 (not ok if you expected 4)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果你是用指针参数那么时可以改变值的，因为<code class="language-plaintext highlighter-rouge">defer</code>语句声明时只保存了指针地址</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span>
  <span class="k">defer</span> <span class="k">func</span> <span class="p">(</span><span class="n">in</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"result =&gt;"</span><span class="p">,</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span> <span class="p">}(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
  
  <span class="n">i</span> <span class="o">=</span> <span class="m">2</span>
  <span class="c">//prints: result =&gt; 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="52-defer-函数的执行">52 defer 函数的执行</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>延迟调用 的执行是在所在函数的结尾（且以相反的顺序），而不是所在的代码块。混淆延迟调用的执行顺序和变量作用域是go萌新很容易犯的错.当你有一个长时间运行的函数比如有<code class="language-plaintext highlighter-rouge">for</code>循环，然后尝试用<code class="language-plaintext highlighter-rouge">defer</code>在每次迭代来清理资源时就会有问题。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"path/filepath"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">)</span> <span class="o">!=</span> <span class="m">2</span> <span class="p">{</span>
        <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">||</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">IsDir</span><span class="p">(){</span>
        <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="n">targets</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="n">filepath</span><span class="o">.</span><span class="n">Walk</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="k">func</span><span class="p">(</span><span class="n">fpath</span> <span class="kt">string</span><span class="p">,</span> <span class="n">fi</span> <span class="n">os</span><span class="o">.</span><span class="n">FileInfo</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">err</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">fi</span><span class="o">.</span><span class="n">Mode</span><span class="p">()</span><span class="o">.</span><span class="n">IsRegular</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">nil</span>
        <span class="p">}</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span><span class="n">fpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">})</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">target</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">targets</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bad target:"</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="s">"error:"</span><span class="p">,</span><span class="n">err</span><span class="p">)</span> <span class="c">//prints error: too many open files</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span> <span class="c">//will not be closed at the end of this code block</span>
        <span class="c">//do something with the file...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>解决这个问题的一个办法时将这段代码块包成一个函数</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"os"</span>
    <span class="s">"path/filepath"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">)</span> <span class="o">!=</span> <span class="m">2</span> <span class="p">{</span>
        <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">||</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">IsDir</span><span class="p">(){</span>
        <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="n">targets</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="n">filepath</span><span class="o">.</span><span class="n">Walk</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="k">func</span><span class="p">(</span><span class="n">fpath</span> <span class="kt">string</span><span class="p">,</span> <span class="n">fi</span> <span class="n">os</span><span class="o">.</span><span class="n">FileInfo</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">err</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">fi</span><span class="o">.</span><span class="n">Mode</span><span class="p">()</span><span class="o">.</span><span class="n">IsRegular</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">nil</span>
        <span class="p">}</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span><span class="n">fpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="no">nil</span>
    <span class="p">})</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">target</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">targets</span> <span class="p">{</span>
        <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bad target:"</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="s">"error:"</span><span class="p">,</span><span class="n">err</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="k">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span> <span class="c">//ok</span>
            <span class="c">//do something with the file...</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>另一个解决方法是去掉<code class="language-plaintext highlighter-rouge">defer</code>语句 :-)</p>

<h2 id="53-失败的类型断言">53 失败的类型断言</h2>
<ul>
  <li>等级：中等</li>
</ul>

<p>类型断言失败将会返回断言类型的“零值”。当有变量隐藏（变量重复定义）的时候可能会导致难以预测的行为。</p>

<h3 id="错误示例-1">错误示例：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">data</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"great"</span>

    <span class="k">if</span> <span class="n">data</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">data</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"[is an int] value =&gt;"</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"[not an int] value =&gt;"</span><span class="p">,</span><span class="n">data</span><span class="p">)</span> 
        <span class="c">//prints: [not an int] value =&gt; 0 (not "great")</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="正确示范-1">正确示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">data</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"great"</span>

    <span class="k">if</span> <span class="n">res</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">data</span><span class="o">.</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"[is an int] value =&gt;"</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"[not an int] value =&gt;"</span><span class="p">,</span><span class="n">data</span><span class="p">)</span> 
        <span class="c">//prints: [not an int] value =&gt; great (as expected)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="54-协程阻塞和资源泄露">54 协程阻塞和资源泄露</h2>
<ul>
  <li>等级： 中级</li>
</ul>

<p>Rob Pike 在2012谷歌I/O大会上的演讲“Go并发模式”中有一系列基本的并发模式。从多个目标中获取第一个结果是其中之一。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">First</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">replicas</span> <span class="o">...</span><span class="n">Search</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>  
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
    <span class="n">searchReplica</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">replicas</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">replicas</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">searchReplica</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">c</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个函数为每一个搜索复制品起了一个协程，每个协程发送它们的搜索数据到结果通道。结果通道中的第一个值被返回。
其他协程中的结果呢？其他协程本身呢？
在<code class="language-plaintext highlighter-rouge">First()</code>函数中的结果通道是无缓冲的，这意味着只有第一个协程返回。其他的协程都阻塞在尝试发送它们的结果。这意味着如果你有多个搜索将会引起资源泄露。
为了避免这种泄露你需要保证每个协程都正确退出。一种可能的解决方案是使用足够大的能保存所有结果的有缓冲通道</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">First</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">replicas</span> <span class="o">...</span><span class="n">Search</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">replicas</span><span class="p">))</span>
    <span class="n">searchReplica</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">replicas</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">query</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">replicas</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">searchReplica</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">c</span> 
<span class="p">}</span>
</code></pre></div></div>
<p>另一种可能的方案是使用有<code class="language-plaintext highlighter-rouge">default</code>的<code class="language-plaintext highlighter-rouge">select</code>语句，并且用有缓冲通道来接受值。<code class="language-plaintext highlighter-rouge">default</code>保证协结果通道不能接受消息时协程不会阻塞。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">First</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">replicas</span> <span class="o">...</span><span class="n">Search</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">searchReplica</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
        <span class="n">searchReplica</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">replicas</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">query</span><span class="p">)</span><span class="o">:</span>
                <span class="k">default</span><span class="o">:</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">replicas</span> <span class="p">{</span>
            <span class="k">go</span> <span class="n">searchReplica</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">&lt;-</span><span class="n">c</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>你也可以使用特殊的取消通道来中断协程</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">First</span><span class="p">(</span><span class="n">query</span> <span class="kt">string</span><span class="p">,</span> <span class="n">replicas</span> <span class="o">...</span><span class="n">Search</span><span class="p">)</span> <span class="n">Result</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">:=</span> <span class="n">amke</span><span class="p">(</span><span class="k">chan</span> <span class="n">Result</span><span class="p">)</span>
    <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
    <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
    <span class="n">searchReplica</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">replicas</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">query</span><span class="p">)</span><span class="o">:</span>
        <span class="k">case</span> <span class="o">&lt;-</span> <span class="n">done</span><span class="o">:</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">replicas</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">searchReplica</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="n">c</span>
<span class="p">}</span>
</code></pre></div></div>
<p>为什么演讲中包含这些bug呢？Rob Pike仅仅时不想将胶片复杂化。这是有道理的，不过萌新Go开发者不去想是否有问题的不假思索的使用这些代码时可能会有问题。</p>
<blockquote>
  <p>译者注：想了半天才明白这段，第一段代码时Rob Pike的演讲，演示并发模式。后面的是博主针对Rob Pike代码找出的bug。</p>
</blockquote>

<h2 id="55-不同零值变量的相同地址">55 不同零值变量的相同地址</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p>如果你有两个不同的变量，那么它们是否应该是不同的地址？Go可能不是这样的 :-) .如果你有多个零值变量，它们在内存中可能有相同的地址。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">{}</span>
  <span class="n">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">{}</span>
  
  <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"same address - a=%p b=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="c">//prints: same address - a=0x1953e4 b=0x1953e4</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="51-iota的第一次使用并不总是零值">51 iota的第一次使用并不总是零值</h2>
<ul>
  <li>等级：中级</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">iota</code>标识符似乎看起来是一个自增的操作符。你定义一个新的常量，第一次你用<code class="language-plaintext highlighter-rouge">iota</code>的时候是0， 第二次你用的时候得到1.但并不总是这样。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="n">azero</span> <span class="o">=</span> <span class="no">iota</span>
  <span class="n">aone</span>  <span class="o">=</span> <span class="no">iota</span>
<span class="p">)</span>

<span class="k">const</span> <span class="p">(</span>
  <span class="n">info</span>  <span class="o">=</span> <span class="s">"processing"</span>
  <span class="n">bzero</span> <span class="o">=</span> <span class="no">iota</span>
  <span class="n">bone</span>  <span class="o">=</span> <span class="no">iota</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">azero</span><span class="p">,</span><span class="n">aone</span><span class="p">)</span> <span class="c">//prints: 0 1</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">bzero</span><span class="p">,</span><span class="n">bone</span><span class="p">)</span> <span class="c">//prints: 1 2</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">iota</code>是一个constant声明代码块当前行的索引操作符，所以如果<code class="language-plaintext highlighter-rouge">iota</code>不是在第一行使用那么初始值就不是0</p>

<h2 id="52-在实例中使用指针接受方法">52 在实例中使用指针接受方法</h2>
<ul>
  <li>等级: 高级</li>
</ul>

<p>只要值是可寻址的那么调用一个指针成员方法是可行的。换句话说，你并不需要再定义一个值成员方法。
但不是所有的变量都是可寻址的。字典元素、接口指向的变量都是不可寻址的。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"name:"</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">printer</span> <span class="k">interface</span> <span class="p">{</span>  
    <span class="nb">print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">d1</span> <span class="o">:=</span> <span class="n">data</span><span class="p">{</span><span class="s">"one"</span><span class="p">}</span>
    <span class="n">d1</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span> <span class="c">//ok</span>

    <span class="k">var</span> <span class="n">in</span> <span class="n">printer</span> <span class="o">=</span> <span class="n">data</span><span class="p">{</span><span class="s">"two"</span><span class="p">}</span> <span class="c">//error</span>
    <span class="n">in</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span>

    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">data</span> <span class="p">{</span><span class="s">"x"</span><span class="o">:</span><span class="n">data</span><span class="p">{</span><span class="s">"three"</span><span class="p">}}</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span><span class="o">.</span><span class="nb">print</span><span class="p">()</span> <span class="c">//error</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="编译错误-11">编译错误：</h3>
<blockquote>
  <p>./main.go:21:6: cannot use data{…} (type data) as type printer in assignment: 
    data does not implement printer (print method has pointer receiver)
./main.go:25:8: cannot call pointer method on m[“x”]
./main.go:25:8: cannot take the address of m[“x”]</p>
</blockquote>

<h2 id="53-更新字典值">53 更新字典值</h2>
<ul>
  <li>等级：高级</li>
</ul>

<p>如果你有一个结构体字典，那么你不能更新单独的结构体字段</p>

<h3 id="错误示范-18">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">data</span> <span class="p">{</span><span class="s">"x"</span><span class="o">:</span><span class="p">{</span><span class="s">"one"</span><span class="p">}}</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"two"</span> <span class="c">//cannot assign to struct field m["x"].name in map</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="编译失败-3">编译失败：</h3>
<blockquote>
  <p>./main.go:9:14: cannot assign to struct field m[“x”].name in map</p>
</blockquote>

<p>这行不通因为字典元素是不可寻址的。
另一个让go萌新迷惑的地方是切片元素是可寻址的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">data</span> <span class="p">{{</span><span class="s">"one"</span><span class="p">}}</span>
    <span class="n">s</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"two"</span> <span class="c">//ok</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>    <span class="c">//prints: [{two}]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>值得一提的是前一阵子在某个go编译器(gccgo)中是可以更新字典元素的，但很快又被修复了 :-) 这被认为是go 1.3的一个潜在特性。但在那时没有重要到需要支持，所以仍然在待办列表中。
第一种方法是使用一个临时变量</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">data</span> <span class="p">{</span><span class="s">"x"</span><span class="o">:</span><span class="p">{</span><span class="s">"one"</span><span class="p">}}</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span>
    <span class="n">r</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"two"</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v"</span><span class="p">,</span><span class="n">m</span><span class="p">)</span> <span class="c">//prints: map[x:{two}]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一个方法是使用指针字典</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">data</span> <span class="p">{</span><span class="s">"x"</span><span class="o">:</span><span class="p">{</span><span class="s">"one"</span><span class="p">}}</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"two"</span> <span class="c">//ok</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">])</span> <span class="c">//prints: &amp;{two}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外，下面的代码执行结果是什么？</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>  
    <span class="n">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">m</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">data</span> <span class="p">{</span><span class="s">"x"</span><span class="o">:</span><span class="p">{</span><span class="s">"one"</span><span class="p">}}</span>
    <span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"two"</span> <span class="c">//ok</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s">"x"</span><span class="p">])</span> <span class="c">//prints: &amp;{two}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>译者注：
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x8 pc=0x497bbd]</p>
</blockquote>

<h2 id="54-nil接口和nil接口值">54 <code class="language-plaintext highlighter-rouge">nil</code>接口和<code class="language-plaintext highlighter-rouge">nil</code>接口值</h2>
<ul>
  <li>等级： 高级</li>
</ul>

<p>这是在Go中第二常见的陷阱，因为接口不是指针尽管它们像指针。接口值只有在他们的类型和值字段都是<code class="language-plaintext highlighter-rouge">nil</code>的时候才是<code class="language-plaintext highlighter-rouge">nil</code>.
接口类型和值字段是根据创建对应接口值的变量的类型和值来填充的。当你尝试检查一个接口值是否为<code class="language-plaintext highlighter-rouge">nil</code>时有可能导致未知的行为。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">var</span> <span class="n">data</span> <span class="o">*</span><span class="kt">byte</span>
    <span class="k">var</span> <span class="n">in</span> <span class="k">interface</span><span class="p">{}</span>

    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">data</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span> <span class="c">//prints: &lt;nil&gt; true</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">in</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>     <span class="c">//prints: &lt;nil&gt; true</span>

    <span class="n">in</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">in</span> <span class="o">==</span> <span class="no">nil</span><span class="p">)</span>     <span class="c">//prints: &lt;nil&gt; false</span>
    <span class="c">//'data' is 'nil', but 'in' is not 'nil'</span>
<span class="p">}</span>
</code></pre></div></div>
<p>当你有函数要返回接口的时候一定要小心这个陷阱。</p>

<h3 id="错误示范-19">错误示范：</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">doit</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">arg</span> <span class="kt">int</span><span class="p">)</span> <span class="k">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">result</span> <span class="o">*</span><span class="k">struct</span><span class="p">{}</span> <span class="o">=</span> <span class="no">nil</span>

        <span class="k">if</span><span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">struct</span><span class="p">{}{}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">res</span> <span class="o">:=</span> <span class="n">doit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">res</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"good result:"</span><span class="p">,</span><span class="n">res</span><span class="p">)</span> <span class="c">//prints: good result: &lt;nil&gt;</span>
        <span class="c">//'res' is not 'nil', but its value is 'nil'</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="正确示例-18">正确示例</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">doit</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">arg</span> <span class="kt">int</span><span class="p">)</span> <span class="k">interface</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">var</span> <span class="n">result</span> <span class="o">*</span><span class="k">struct</span><span class="p">{}</span> <span class="o">=</span> <span class="no">nil</span>

        <span class="k">if</span><span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">struct</span><span class="p">{}{}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">nil</span> <span class="c">//return an explicit 'nil'</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">res</span> <span class="o">:=</span> <span class="n">doit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">);</span> <span class="n">res</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"good result:"</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"bad result (res is nil)"</span><span class="p">)</span> <span class="c">//here as expected</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="55-堆栈变量">55 堆栈变量</h2>
<ul>
  <li>等级：高级</li>
</ul>

<p>你并不总是知道你的变量是分配在堆上和还是栈上。在C++里如果使用<code class="language-plaintext highlighter-rouge">new</code>操作符创建变量意味着变量在堆上分配。在go中即使你用了<code class="language-plaintext highlighter-rouge">new()</code>或<code class="language-plaintext highlighter-rouge">make()</code>，仍然是由编译器来决定变量的分配。编译器选择存储变量位置的根据是它的大小和“逃逸分析”的结果。这也意味着返回局部变量的引用是OK的，而这在其他语言如C或C++是不行的。
如果你需要知道你的变量分配的位置需要在”go build”或”go run”传入”-m” 的gcflag（例如 <code class="language-plaintext highlighter-rouge">go run -gcflags -m app.go</code>）</p>

<h2 id="56-gomaxprocs-并发和并行">56 GOMAXPROCS, 并发和并行</h2>
<ul>
  <li>等级： 高级</li>
</ul>

<p>Go1.4 和更低的版本仅仅使用一个执行上下文/OS线程。这意味着任意时间只有一个协程可以执行。从1.5后GO使用<code class="language-plaintext highlighter-rouge">runtime.NumCPU()</code>返回的逻辑CPU核数来设置执行上下文的数量。这个数字不一定等同于那你的系统的最大逻辑CPU核数，这取决于你进程的CPU亲和性设置。你可以通过改变<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>环境变量来设置这个值或者调用<code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS()</code>函数。</p>

<p>这里有个普遍错误就是<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>代表go将会用来起协程的CPU数量。<code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS()</code>函数文档增加了更多困惑。<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>变量的描述(https://golang.org/pkg/runtime/)对OS 线程数做了较好的描述。</p>

<p>你可以设置<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>大于你的CPU数量。从1.10开始GOMAXPROCS没有限制了。<code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>的最大值之前是256在1.9版本增加到了1024.</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">))</span>	<span class="c">// 4</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">())</span>	<span class="c">// 4</span>
	<span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">20</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">))</span>	<span class="c">// 20</span>
	<span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">300</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">))</span>	<span class="c">// Go 1.9.2 // 300</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="57-读写操作的重排序">57 读写操作的重排序</h2>
<ul>
  <li>等级：高级</li>
</ul>

<p>go可能会重排某些操作，但它会确保go协程中整体行为不会改变。但是，这并不能保证多协程下执行的顺序。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"runtime"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="n">_</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>

<span class="k">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span>

<span class="k">func</span> <span class="n">u1</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">a</span> <span class="o">=</span> <span class="m">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="m">2</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">u2</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">a</span> <span class="o">=</span> <span class="m">3</span>
    <span class="n">b</span> <span class="o">=</span> <span class="m">4</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">p</span><span class="p">()</span> <span class="p">{</span>  
    <span class="nb">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="k">go</span> <span class="n">u1</span><span class="p">()</span>
    <span class="k">go</span> <span class="n">u2</span><span class="p">()</span>
    <span class="k">go</span> <span class="n">p</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果执行这段代码多次，你会发现很多<code class="language-plaintext highlighter-rouge">a</code> <code class="language-plaintext highlighter-rouge">b</code>变量值的组合</p>
<blockquote>
  <p>1
2</p>
</blockquote>

<blockquote>
  <p>3
4</p>
</blockquote>

<blockquote>
  <p>0
2</p>
</blockquote>

<blockquote>
  <p>0
0</p>
</blockquote>

<blockquote>
  <p>1 
4</p>
</blockquote>

<p>最有意思的是<code class="language-plaintext highlighter-rouge">02</code>这对组合。这意味着<code class="language-plaintext highlighter-rouge">b</code>在<code class="language-plaintext highlighter-rouge">a</code>之前更新.
如果你需要保证在多协程下读写的循序，你需要使用通道或者<code class="language-plaintext highlighter-rouge">sync</code>包里相应的结构体</p>

<h2 id="58-抢先调度">58 抢先调度</h2>
<ul>
  <li>等级：高级</li>
</ul>

<p>有可能存在调皮的协程阻挡了其他协程的运行。比如当你有一个<code class="language-plaintext highlighter-rouge">for</code>循环但是没有开启调度器的时候。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">done</span> <span class="o">:=</span> <span class="no">false</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
        <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">for</code>循环并不一定是空的，只要包含的代码里没有触发调度器的就会有问题
调度器将会在GC、”go”关键字、阻塞通道的操作、阻塞系统调用、锁操作后运行。另外有内联函数的时候也可能运行。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">done</span> <span class="o">:=</span> <span class="no">false</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
        <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"not done!"</span><span class="p">)</span> <span class="c">//not inlined</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>想知道你在<code class="language-plaintext highlighter-rouge">for</code>循环中调用的函数是不是内联函数，请在”go build”/”go run”的gc flag中传入”-m”参数（比如 <code class="language-plaintext highlighter-rouge">go build -gcflags -m</code>）</p>

<p>另一个选择是显式的调用调度器，可以使用“runtime”包中的<code class="language-plaintext highlighter-rouge">Gosched()</code>函数。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>  
    <span class="s">"fmt"</span>
    <span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">done</span> <span class="o">:=</span> <span class="no">false</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">(){</span>
        <span class="n">done</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="o">!</span><span class="n">done</span> <span class="p">{</span>
        <span class="n">runtime</span><span class="o">.</span><span class="n">Gosched</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意上面的代码包含了竞态条件。这是为了显示调度器问题有意为之的。</p>

<h2 id="59-导入c和多行导入代码块">59. 导入C和多行导入代码块</h2>
<ul>
  <li>等级：Cgo</li>
</ul>

<p>你需要导入“C”包来使用Cgo。你可以在单行导入也可以按代码块导入</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*
#include &lt;stdlib.h&gt;
*/</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"C"</span>
<span class="p">)</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cs</span> <span class="o">:=</span> <span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"my go string"</span><span class="p">)</span>
  <span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>译者注：此处我运行后不能编译，只能<code class="language-plaintext highlighter-rouge">import "C"</code>才行，不确定是不是和作者go版本不同的原因</p>
</blockquote>

<p>如果你使用<code class="language-plaintext highlighter-rouge">import</code>代码块你不能把其他包放在同一块中。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*
#include &lt;stdlib.h&gt;
*/</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"C"</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cs</span> <span class="o">:=</span> <span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"my go string"</span><span class="p">)</span>
  <span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>编译错误：</p>
<blockquote>
  <p>./main.go:13:2: could not determine kind of name for C.free</p>
</blockquote>

<h2 id="60-引入c和cgo注释中不能有空格">60 引入C和Cgo注释中不能有空格</h2>
<ul>
  <li>等级：Cgo</li>
</ul>

<p>Cgo的第一个问题是<code class="language-plaintext highlighter-rouge">import "C"</code>语句上面的Cgo注释的位置。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*
#include &lt;stdlib.h&gt;
*/</span>

<span class="k">import</span> <span class="s">"C"</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cs</span> <span class="o">:=</span> <span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"my go string"</span><span class="p">)</span>
  <span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>编译错误：</p>
<blockquote>
  <p>./main.go:15:2: could not determine kind of name for C.free
保证在<code class="language-plaintext highlighter-rouge">import "C"</code>语句上没有任何空行</p>
</blockquote>

<h2 id="61-无法调用可变参数的c函数">61 无法调用可变参数的C函数</h2>
<ul>
  <li>等级：Cgo</li>
</ul>

<p>你不能直接调用可变参数的C函数</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
*/</span>
<span class="k">import</span> <span class="s">"C"</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cstr</span> <span class="o">:=</span> <span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"go"</span><span class="p">)</span>
  <span class="n">C</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cstr</span><span class="p">)</span> <span class="c">//not ok</span>
  <span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cstr</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>
<p>编译错误：</p>
<blockquote>
  <p>./main.go:15:2: unexpected type: …</p>
</blockquote>

<p>您必须将可变参数的C函数封装在具有已知参数数量的函数中</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void out(char* in) {
  printf("%s\n", in);
}
*/</span>
<span class="k">import</span> <span class="s">"C"</span>

<span class="k">import</span> <span class="p">(</span>
  <span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cstr</span> <span class="o">:=</span> <span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"go"</span><span class="p">)</span>
  <span class="n">C</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">cstr</span><span class="p">)</span> <span class="c">//ok</span>
  <span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cstr</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

  </div><a class="u-url" href="/go/2022/01/04/gotchas_and_common_mistakes_in_golang.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">zand&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">zand&#39;s blog</li><li><a class="u-email" href="mailto:zand.wang@foxmail.com">zand.wang@foxmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/zandwang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">zandwang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>zand</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
